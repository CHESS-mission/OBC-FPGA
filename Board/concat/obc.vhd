-- VHDL Entity Board.obc_test_circuit.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:24:14 07.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY obc_test_circuit IS
   GENERIC( 
      PinNumber : integer := 32;
      dataBitNb : integer := 8
   );
   PORT( 
      SPI1_MISO   : IN     std_ulogic;
      SPI2_MISO   : IN     std_ulogic;
      SPI3_MISO   : IN     std_ulogic;
      SPI4_MISO   : IN     std_ulogic;
      clock       : IN     std_ulogic;
      fpgaIO0     : IN     std_logic;
      fpgaIO1     : IN     std_logic;
      fpgaIO2     : IN     std_logic;
      reset_N     : IN     std_ulogic;
      ICSPCLK     : OUT    std_logic;
      ICSPDAT     : OUT    std_logic;
      Led1        : OUT    std_logic;
      Led2        : OUT    std_logic;
      Led3        : OUT    std_logic;
      Led4        : OUT    std_logic;
      Led5        : OUT    std_logic;
      MCLR        : OUT    std_logic;
      SPI1_MOSI   : OUT    std_ulogic;
      SPI1_SS1_n  : OUT    std_ulogic;
      SPI1_SS2_n  : OUT    std_ulogic;
      SPI1_SS3_n  : OUT    std_ulogic;
      SPI1_sClk   : OUT    std_ulogic;
      SPI1_unused : OUT    std_uLogic;
      SPI2_MOSI   : OUT    std_ulogic;
      SPI2_SS1_n  : OUT    std_ulogic;
      SPI2_sClk   : OUT    std_ulogic;
      SPI2_unused : OUT    std_uLogic;
      SPI3_MOSI   : OUT    std_ulogic;
      SPI3_SS1_n  : OUT    std_ulogic;
      SPI3_SS2_n  : OUT    std_ulogic;
      SPI3_sClk   : OUT    std_ulogic;
      SPI3_unused : OUT    std_uLogic;
      SPI4_MOSI   : OUT    std_ulogic;
      SPI4_SS1_n  : OUT    std_ulogic;
      SPI4_SS2_n  : OUT    std_ulogic;
      SPI4_sClk   : OUT    std_ulogic;
      SPI4_unused : OUT    std_uLogic;
      fpgaIO3     : OUT    std_logic;
      fpgaIO4     : OUT    std_logic;
      fpgaIO5     : OUT    std_logic;
      fpgaIO6     : OUT    std_logic;
      mem_Hold    : OUT    std_logic;
      mem_WP      : OUT    std_logic
   );

-- Declarations

END obc_test_circuit ;





-- VHDL Entity OBC.Test.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 10:30:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY Test IS
   PORT( 
      clock : IN     std_ulogic;
      reset : IN     std_ulogic;
      Led1  : OUT    std_logic;
      Led2  : OUT    std_logic;
      Led3  : OUT    std_logic;
      Led4  : OUT    std_logic;
      Led5  : OUT    std_logic
   );

-- Declarations

END Test ;





--
-- VHDL Architecture OBC.Test.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 10:30:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;


ARCHITECTURE struct OF Test IS

   -- Architecture declarations

   -- Internal signal declarations



BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 5 eb5
     process(clock, reset)
     begin
       if reset = '1' then
         Led1 <= '0';
       elsif rising_edge(clock) then
         Led1 <= not Led1;
       end if;
     end process;

   -- HDL Embedded Text Block 6 eb6
     process(clock, reset)
     begin
       if reset = '1' then
         Led2 <= '0';
   	  Led3 <= '0';
   	  Led4 <= '0';
   	  Led5 <= '0';
       elsif rising_edge(clock) then
         Led2 <= '0';
   	  Led3 <= '0';
   	  Led4 <= '0';
   	  Led5 <= '0';
       end if;
     end process;


   -- Instance port mappings.

END struct;




-- VHDL Entity Board.SPI_IO_Tristate.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 15:56:23 02.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY SPI_IO_Tristate IS
   GENERIC( 
      dataBitNb : integer := 8;
      PinNumber : integer := 32
   );
   PORT( 
      SPI_DataIn       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI_endTransfer  : IN     std_logic;
      SPI_masterFull   : IN     std_ulogic;
      SPI_slaveEmpty   : IN     std_ulogic;
      writeEnable_Risc : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      DataIn           : OUT    std_logic_vector (dataBitNb-1 DOWNTO 0);
      endTransfer      : OUT    std_uLogic;
      masterFull       : OUT    std_uLogic;
      slaveEmpty       : OUT    std_uLogic
   );

-- Declarations

END SPI_IO_Tristate ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity IO.tristateBufferULogic.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 16:28:40 20.08.2009
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY tristateBufferULogic IS
   GENERIC( 
      delay : time := gateDelay
   );
   PORT( 
      OE   : IN     std_ulogic;
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END tristateBufferULogic ;





ARCHITECTURE sim OF tristateBufferULogic IS
BEGIN
  out1 <= in1 after delay when OE = '1' else 'Z' after delay;
END ARCHITECTURE sim;





-- VHDL Entity IO.tristateBufferULogicVector.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 16:37:54 20.08.2009
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY tristateBufferULogicVector IS
   GENERIC( 
      dataNbBits : positive := 8;
      delay      : time     := gateDelay
   );
   PORT( 
      OE   : IN     std_ulogic;
      in1  : IN     std_uLogic_vector (dataNbBits-1 DOWNTO 0);
      out1 : OUT    std_Logic_vector (dataNbBits-1 DOWNTO 0)
   );

-- Declarations

END tristateBufferULogicVector ;





ARCHITECTURE sim OF tristateBufferULogicVector IS
BEGIN
  out1 <= std_logic_vector(in1) after delay when OE = '1' else (others => 'Z') after delay;
END ARCHITECTURE sim;





-- VHDL Entity Gates.inverter.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:19:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY inverter IS
   GENERIC( 
      delay : time := gateDelay
   );
   PORT( 
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity Gates.and4inv4.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:19:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY and4inv4 IS
   GENERIC( 
      delay : time := gateDelay
   );
   PORT( 
      in1  : IN     std_uLogic;
      in2  : IN     std_uLogic;
      in3  : IN     std_uLogic;
      in4  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END and4inv4 ;





ARCHITECTURE sim OF and4inv4 IS
BEGIN
  out1 <= (not in1) and (not in2) and (not in3) and (not in4) after delay;
END ARCHITECTURE sim;




-- VHDL Entity Gates.and2.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:19:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY and2 IS
   GENERIC( 
      delay : time := gateDelay
   );
   PORT( 
      in1  : IN     std_uLogic;
      in2  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END and2 ;





ARCHITECTURE sim OF and2 IS
BEGIN
  out1 <= in1 and in2 after delay;
END ARCHITECTURE sim;




--
-- VHDL Architecture Board.SPI_IO_Tristate.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 16:04:14 02.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY IO;

ARCHITECTURE struct OF SPI_IO_Tristate IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL OE   : std_ulogic;
   SIGNAL in1  : std_uLogic;
   SIGNAL in2  : std_uLogic;
   SIGNAL out1 : std_uLogic;
   SIGNAL out2 : std_uLogic;
   SIGNAL out3 : std_uLogic;


   -- Component Declarations
   COMPONENT and2
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      in1  : IN     std_uLogic ;
      in2  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT and4inv4
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      in1  : IN     std_uLogic ;
      in2  : IN     std_uLogic ;
      in3  : IN     std_uLogic ;
      in4  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT inverter
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT tristateBufferULogic
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      OE   : IN     std_ulogic ;
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT tristateBufferULogicVector
   GENERIC (
      dataNbBits : positive := 8;
      delay      : time     := gateDelay
   );
   PORT (
      OE   : IN     std_ulogic ;
      in1  : IN     std_uLogic_vector (dataNbBits-1 DOWNTO 0);
      out1 : OUT    std_Logic_vector (dataNbBits-1 DOWNTO 0)
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : and2 USE ENTITY Gates.and2;
   FOR ALL : and4inv4 USE ENTITY Gates.and4inv4;
   FOR ALL : inverter USE ENTITY Gates.inverter;
   FOR ALL : tristateBufferULogic USE ENTITY IO.tristateBufferULogic;
   FOR ALL : tristateBufferULogicVector USE ENTITY IO.tristateBufferULogicVector;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   U_5 : and2
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => in1,
         in2  => in2,
         out1 => OE
      );
   U_3 : and4inv4
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => writeEnable_Risc(8),
         in2  => writeEnable_Risc(9),
         in3  => writeEnable_Risc(10),
         in4  => writeEnable_Risc(11),
         out1 => in1
      );
   U_4 : and4inv4
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => writeEnable_Risc(12),
         in2  => writeEnable_Risc(13),
         in3  => writeEnable_Risc(14),
         in4  => writeEnable_Risc(15),
         out1 => in2
      );
   U_0 : inverter
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => writeEnable_Risc(17),
         out1 => out1
      );
   U_1 : inverter
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => writeEnable_Risc(19),
         out1 => out2
      );
   U_2 : inverter
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => writeEnable_Risc(20),
         out1 => out3
      );
   I11 : tristateBufferULogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         OE   => out1,
         in1  => SPI_masterFull,
         out1 => masterFull
      );
   I13 : tristateBufferULogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         OE   => out2,
         in1  => SPI_slaveEmpty,
         out1 => slaveEmpty
      );
   I14 : tristateBufferULogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         OE   => out3,
         in1  => SPI_endTransfer,
         out1 => endTransfer
      );
   I12 : tristateBufferULogicVector
      GENERIC MAP (
         dataNbBits => DataBitNb,
         delay      => gateDelay
      )
      PORT MAP (
         OE   => OE,
         in1  => SPI_DataIn,
         out1 => DataIn
      );

END struct;




-- VHDL Entity OBC.gpioBankControl.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 09:50:45 01.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY gpioBankControl IS
   GENERIC( 
      PinNumber : positive := 32
   );
   PORT( 
      write   : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      writeEn : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      read    : OUT    std_logic_vector (PinNumber-1 DOWNTO 0);
      pins    : INOUT  std_logic_vector (PinNumber-1 DOWNTO 0)
   );

-- Declarations

END gpioBankControl ;





-- VHDL Entity Gates.bufferUlogicVector.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:19:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY bufferUlogicVector IS
   GENERIC( 
      dataBitNb : positive := 8;
      delay     : time     := gateDelay
   );
   PORT( 
      in1  : IN     std_uLogic_vector (dataBitNb-1 DOWNTO 0);
      out1 : OUT    std_uLogic_vector (dataBitNb-1 DOWNTO 0)
   );

-- Declarations

END bufferUlogicVector ;





ARCHITECTURE sim OF bufferUlogicVector IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




--
-- VHDL Architecture OBC.gpioBankControl.struct_tristate
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 09:55:32 01.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY IO;

ARCHITECTURE struct_tristate OF gpioBankControl IS

   -- Architecture declarations

   -- Internal signal declarations


   -- Component Declarations
   COMPONENT bufferUlogicVector
   GENERIC (
      dataBitNb : positive := 8;
      delay     : time     := gateDelay
   );
   PORT (
      in1  : IN     std_uLogic_vector (dataBitNb-1 DOWNTO 0);
      out1 : OUT    std_uLogic_vector (dataBitNb-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT tristateBufferULogic
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      OE   : IN     std_ulogic ;
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : bufferUlogicVector USE ENTITY Gates.bufferUlogicVector;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   U_1 : bufferUlogicVector
      GENERIC MAP (
         dataBitNb => PinNumber,
         delay     => gateDelay
      )
      PORT MAP (
         in1  => pins,
         out1 => read
      );

   g0: FOR i IN 0 TO PinNumber-1 GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : tristateBufferULogic USE ENTITY IO.tristateBufferULogic;
   -- pragma synthesis_on

   BEGIN
      U_0 : tristateBufferULogic
         GENERIC MAP (
            delay => gateDelay
         )
         PORT MAP (
            OE   => writeEn(i),
            in1  => write(i),
            out1 => pins(i)
         );
   END;
   END GENERATE g0;

END struct_tristate;




-- VHDL Entity Gates.bufferUlogic.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:19:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY bufferUlogic IS
   GENERIC( 
      delay : time := gateDelay
   );
   PORT( 
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END bufferUlogic ;





ARCHITECTURE sim OF bufferUlogic IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:05 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
   PORT( 
      CLK : IN     std_uLogic;
      CLR : IN     std_uLogic;
      D   : IN     std_uLogic;
      Q   : OUT    std_uLogic
   );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
   PORT( 
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





-- VHDL Entity SPI.spiFifo.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 07:39:39 11.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY spiFifo IS
   GENERIC( 
      dataBitNb      : positive   := 8;
      fifoDepth      : positive   := 8;      --Max nbr of sequential transfers
      spiClockPeriod : positive   := 1;      --SPI clock divider
      spiFramePeriod : positive   := 1;      --SPI Inter Frame Gap
      cPol           : std_ulogic := '0';
      cPha           : std_ulogic := '0'
   );
   PORT( 
      slaveRd     : IN     std_ulogic;
      slaveData   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      clock       : IN     std_ulogic;
      MISO        : IN     std_ulogic;
      reset       : IN     std_ulogic;
      MOSI        : OUT    std_ulogic;
      slaveEmpty  : OUT    std_ulogic;
      masterFull  : OUT    std_ulogic;
      masterData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      masterWr    : IN     std_ulogic;
      sClk        : OUT    std_ulogic;
      endTransfer : OUT    std_logic;
      SS_n        : OUT    std_ulogic
   );

-- Declarations

END spiFifo ;





-- VHDL Entity Memory.FIFO.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO IS
   GENERIC( 
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT( 
      write   : IN     std_ulogic;
      clock   : IN     std_ulogic;
      reset   : IN     std_ulogic;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic;
      full    : OUT    std_ulogic
   );

-- Declarations

END FIFO ;





-- VHDL Entity Memory.FIFO_oneRegister.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_oneRegister IS
   GENERIC( 
      dataBitNb : positive := 8
   );
   PORT( 
      write   : IN     std_ulogic;
      clock   : IN     std_ulogic;
      reset   : IN     std_ulogic;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic;
      full    : OUT    std_ulogic
   );

-- Declarations

END FIFO_oneRegister ;





architecture oneRegister of FIFO_oneRegister is

  signal dataRegister: std_ulogic_vector(dataIn'range);

begin

  writeReg: process(reset, clock)
  begin
    if reset = '1' then
      dataRegister <= (others => '0');
    elsif rising_edge(clock) then
      if write = '1' then
        dataRegister <= dataIn;
      end if;
    end if;
  end process writeReg;

  dataOut <= dataRegister;

  manageFlags: process(reset, clock)
  begin
    if reset = '1' then
      empty <= '1';
      full  <= '0';
    elsif rising_edge(clock) then
      if write = '1' then
        empty <= '0';
        full  <= '1';
      elsif read = '1' then
        empty <= '1';
        full  <= '0';
      end if;
    end if;
  end process manageFlags;

end oneRegister;





-- VHDL Entity Memory.FIFO_bram.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_bram IS
   GENERIC( 
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT( 
      write   : IN     std_ulogic;
      clock   : IN     std_ulogic;
      reset   : IN     std_ulogic;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic;
      full    : OUT    std_ulogic
   );

-- Declarations

END FIFO_bram ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




library Common;
  use Common.CommonLib.all;

architecture RTL of FIFO_bram is

  subtype register_type is std_ulogic_vector(dataIn'high downto 0);
  type memory_type is array (0 to depth-1) of register_type;

  signal writeCounter: unsigned(requiredBitNb(depth-1)-1 downto 0);
  signal readCounter: unsigned(writeCounter'range);
  signal memoryArray: memory_type;

  type fifoStateType is (
    sEmpty, sFull,
    sRead, sWrite, sWriteFirst,
    sReadWrite, sWait
  );
  signal fifoState: fifoStateType;
  signal emptyCondition, fullCondition, empty_int: std_ulogic;

begin
  ------------------------------------------------------------------------------
                                                      -- read and write counters
  updateWriteCounter: process(reset, clock)
  begin
    if reset = '1' then
      writeCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (write = '1') and  (fullCondition = '0') then
        writeCounter <= writeCounter + 1;
      end if;
    end if;
  end process updateWriteCounter;

  updateReadCounter: process(reset, clock)
  begin
    if reset = '1' then
      readCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '1') and  (empty_int = '0') then
        readCounter <= readCounter + 1;
      end if;
    end if;
  end process updateReadCounter;

  ------------------------------------------------------------------------------
                                                                -- memory access
  writeMem: process(clock)
  begin
    if rising_edge(clock) then
      if (write = '1') and (fullCondition = '0') then
        memoryArray(to_integer(writeCounter)) <= dataIn;
      end if;
    end if;
  end process writeMem;

  readMem: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '0') or (empty_int = '1') then
        dataOut <= memoryArray(to_integer(readCounter));
      else
        dataOut <= memoryArray(to_integer(readCounter+1));
      end if;
    end if;
  end process readMem;

  ------------------------------------------------------------------------------
                                                                     -- controls
  emptyCondition <= '1' when
      ( (fifoState = sRead) and (writeCounter = readCounter) ) or
        (fifoState = sEmpty)
    else '0';

  fullCondition <= '1' when
      ( (fifoState = sWrite) and (writeCounter = readCounter) ) or
        (fifoState = sFull)
    else '0';


  fifoControl: process(reset, clock)
  begin
    if reset = '1' then
      fifoState <= sEmpty;
    elsif rising_edge(clock) then
      case fifoState is
        when sEmpty =>
          if write = '1' then
            fifoState <= sWriteFirst;
          end if;
        when sFull =>
          if (read = '1') then
            fifoState <= sRead;
          end if;
        when sRead =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
		      elsif emptyCondition = '1' then
            fifoState <= sEmpty;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWriteFirst =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWrite =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
		      elsif fullCondition = '1' then
            fifoState <= sFull;
          elsif write = '1' then
            fifoState <= sWrite;
          else
            fifoState <= sWait;
          end if;
        when sReadWrite =>
          if (read = '0') and (write = '0') then
            fifoState <= sWait;
          elsif (read = '1') and (write = '0') then
            fifoState <= sRead;
          elsif (write = '1') and (read = '0') then
            fifoState <= sWrite;
          end if;
        when sWait =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
          elsif write = '1' then
            fifoState <= sWrite;
          end if;
        when others => null;
      end case;
    end if;
  end process fifoControl;
  

  full <= '1' when 
        (fifoState = sFull) or
        (fullCondition = '1')
    else '0';

  empty_int <= '1' when
        (fifoState = sEmpty) or
        (fifoState = sWriteFirst) or
        ( (emptyCondition = '1') and (fifoState = sRead) )
    else '0';
  empty <= empty_int;
  
end RTL;




--
-- VHDL Architecture Memory.FIFO.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:16 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Memory;

ARCHITECTURE struct OF FIFO IS

   -- Architecture declarations

   -- Internal signal declarations


   -- Component Declarations
   COMPONENT FIFO_bram
   GENERIC (
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT (
      write   : IN     std_ulogic ;
      clock   : IN     std_ulogic ;
      reset   : IN     std_ulogic ;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic ;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic ;
      full    : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT FIFO_oneRegister
   GENERIC (
      dataBitNb : positive := 8
   );
   PORT (
      write   : IN     std_ulogic ;
      clock   : IN     std_ulogic ;
      reset   : IN     std_ulogic ;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic ;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic ;
      full    : OUT    std_ulogic 
   );
   END COMPONENT;


BEGIN

   -- Instance port mappings.

   g0: IF depth <= 1 GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : FIFO_oneRegister USE ENTITY Memory.FIFO_oneRegister;
   -- pragma synthesis_on

   BEGIN
      I1 : FIFO_oneRegister
         GENERIC MAP (
            dataBitNb => dataBitNb
         )
         PORT MAP (
            write   => write,
            clock   => clock,
            reset   => reset,
            dataOut => dataOut,
            read    => read,
            dataIn  => dataIn,
            empty   => empty,
            full    => full
         );
   END;
   END GENERATE g0;

   g1: IF depth > 1 GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
   -- pragma synthesis_on

   BEGIN
      I0 : FIFO_bram
         GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => depth
         )
         PORT MAP (
            write   => write,
            clock   => clock,
            reset   => reset,
            dataOut => dataOut,
            read    => read,
            dataIn  => dataIn,
            empty   => empty,
            full    => full
         );
   END;
   END GENERATE g1;

END struct;




-- VHDL Entity SPI.spiTimer.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:39:54 31.10.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY spiTimer IS
   GENERIC( 
      clockPeriod : positive := 1;
      framePeriod : positive := 1
   );
   PORT( 
      en2x      : OUT    std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      sendFrame : OUT    std_ulogic
   );

-- Declarations

END spiTimer ;





LIBRARY Common;
USE Common.CommonLib.all;

architecture RTL of spiTimer is

  signal clockPeriodCounter: unsigned(requiredBitNb(clockPeriod)-1 downto 0);
  signal clockPeriodEnd: std_uLogic;
  signal framePeriodCounter: unsigned(requiredBitNb(framePeriod)-1 downto 0);
  signal framePeriodEnd: std_uLogic;

begin

  divide1: process(reset, clock)
  begin
    if reset = '1' then
      clockPeriodCounter <= (others => '0');
    elsif rising_edge(clock) then
      if clockPeriodEnd = '1' then
        clockPeriodCounter <= (others => '0');
      else
        clockPeriodCounter <= clockPeriodCounter + 1;
      end if;
    end if;
  end process divide1;

  endOfCount1: process(clockPeriodCounter)
  begin
    if clockPeriodCounter >= clockPeriod-1 then
      clockPeriodEnd <= '1';
    else
      clockPeriodEnd <= '0';
    end if;
  end process endOfCount1;

  en2x <= clockPeriodEnd;

  divide2: process(reset, clock)
  begin
    if reset = '1' then
      framePeriodCounter <= (others => '0');
    elsif rising_edge(clock) then
      if framePeriodEnd = '1' then
        framePeriodCounter <= (others => '0');
      else
        framePeriodCounter <= framePeriodCounter + 1;
      end if;
    end if;
  end process divide2;

  endOfCount2: process(framePeriodCounter)
  begin
    if framePeriodCounter >= framePeriod-1 then
      framePeriodEnd <= '1';
    else
      framePeriodEnd <= '0';
    end if;
  end process endOfCount2;

  sendFrame <= framePeriodEnd;

end RTL;




-- VHDL Entity SPI.spiTransceiver.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:39:54 31.10.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY spiTransceiver IS
   GENERIC( 
      dataBitNb : positive   := 8;
      cPol      : std_ulogic := '0';
      cPha      : std_ulogic := '0'
   );
   PORT( 
      sClk      : OUT    std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      dataOut   : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataWr    : IN     std_ulogic;
      dataIn    : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      en2x      : IN     std_ulogic;
      MOSI      : OUT    std_ulogic;
      MISO      : IN     std_ulogic;
      slaveSel  : OUT    std_ulogic;
      dataValid : OUT    std_ulogic;
      busy      : OUT    std_ulogic
   );

-- Declarations

END spiTransceiver ;





--------------------------------------------------------------------------------
-- Copyright 2013 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- SPI master interface
--   More information: http://wiki.hevs.ch/uit/index.php5/Components/IP/SPI  
--
--   Created on 2012-10-01
--
--   Version: 1.0
--   Author: François Corthay (francois.corthay@hevs.ch)
--------------------------------------------------------------------------------

LIBRARY Common;
USE Common.CommonLib.all;

architecture RTL of spiTransceiver is

  signal sequenceCounter    : unsigned(requiredBitNb(2*dataBitNb+1)-1 downto 0);
  signal sequenceCounterEnd : std_uLogic;
  signal sending            : std_uLogic;
  signal dataValid1         : std_uLogic;
  signal dataAvail          : std_ulogic;
  signal serialClock        : std_uLogic;
  signal slaveSel_int       : std_ulogic;

  signal dataOutShift           : std_uLogic;
  signal dataOutShiftReg        : std_ulogic_vector(dataOut'range);
  signal dataOutBufferReg       : std_ulogic_vector(dataOut'range);
  signal masterOut0, masterOut1 : std_uLogic;

  signal dataInShift, dataInShift1     : std_uLogic;
  signal dataInEndDelayed, dataInStore : std_uLogic;
  signal dataInShiftReg                : std_ulogic_vector(dataIn'range);

begin
  ------------------------------------------------------------------------------
                                                                       -- timing
  countSequence: process(reset, clock)
  begin
    if reset = '1' then
      sequenceCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (slaveSel_int = '0' and dataAvail = '1') then -- first transfer
        sequenceCounter <= sequenceCounter + 1;
      elsif en2x = '1' then
        if sequenceCounterEnd = '1' then
          if dataAvail = '0' then                      -- Last Transfer
            sequenceCounter <= (others => '0');
          else                                         -- Continue with next Transfer
            sequenceCounter <= to_unsigned(1, sequenceCounter'length);
          end if;
        elsif sequenceCounter > 0 then
          sequenceCounter <= sequenceCounter + 1;
        end if;
      end if;
    end if;
  end process countSequence;

  endOfSequence: process(sequenceCounter)
  begin
    if sequenceCounter = 2*dataBitNb+1 then
      sequenceCounterEnd <= '1';
    else
      sequenceCounterEnd <= '0';
    end if;
  end process endOfSequence;

  sending <= '1' when sequenceCounter /= 0 else '0';
  serialClock <= not(sequenceCounter(0)) and sending;

  busy <= dataAvail;
  
  signalValid: process(reset, clock)
  begin
    if reset = '1' then
      dataValid1 <= '0';
      dataValid <= '0';
    elsif rising_edge(clock) then
      dataValid1 <= sequenceCounterEnd and en2x;
      dataValid <= dataValid1;
    end if;
  end process signalValid;

  ------------------------------------------------------------------------------
                                                                     -- data out
  dataOutShift <= en2x when (sequenceCounter(0) = '0') and (sending = '1') else '0';

  outputShiftReg: process(reset, clock)
  begin
    if reset = '1' then
      dataOutBufferReg <= (others => '0');
      dataAvail        <= '0';
      dataOutShiftReg  <= (others => '0');
    elsif rising_edge(clock) then
      -- data buffering
      if dataWr = '1' then
        dataAvail <= '1';
        dataOutBufferReg <= dataOut;
      end if;
      -- read buffered data
      if (slaveSel_int = '1' and dataAvail = '1' and dataValid1 = '1') or -- while sending
         (slaveSel_int = '0' and dataAvail = '1') then                    -- first transfer
        dataOutShiftReg <= dataOutBufferReg;
        dataAvail <= '0';
      elsif dataOutShift = '1' then
        dataOutShiftReg(dataOutShiftReg'high downto 1) <= dataOutShiftReg(dataOutShiftReg'high-1 downto 0);
      end if;
    end if;
  end process outputShiftReg;

  masterOut0 <= dataOutShiftReg(dataOutShiftReg'high);

  delayMasterOut: process(reset, clock)
  begin
    if reset = '1' then
      masterOut1 <= '0';
    elsif rising_edge(clock) then
      if en2x = '1' then
        masterOut1 <= masterOut0;
      end if;
    end if;
  end process delayMasterOut;

  deglitchOutputs: process(reset, clock)
  begin
    if reset = '1' then
      sClk         <= '0';
      MOSI         <= '0';
      slaveSel_int <= '0';
    elsif rising_edge(clock) then
      if cPol = '0' then
        sClk <= serialClock;
      else
        sClk <= not(serialClock);
      end if;
      if cPha = '0' then
        MOSI <= masterOut0;
      else
        MOSI <= masterOut1;
      end if;
      slaveSel_int <= sending;
    end if;
  end process deglitchOutputs;
  
  slaveSel <= slaveSel_int;

  ------------------------------------------------------------------------------
                                                                      -- data in
  dataInShift <= en2x
--      when (sequenceCounter(0) = '0') and (sending = '1')
      when ( (sequenceCounter(0) = '1') and (sending = '1') and (cPha = '0') )
        or ( (sequenceCounter(0) = '0') and (sending = '1') and (cPha = '1') )
    else '0';

  delayInShiftEn: process(reset, clock)
  begin
    if reset = '1' then
      dataInShift1 <= '0';
    elsif rising_edge(clock) then
      dataInShift1 <= dataInShift;
    end if;
  end process delayInShiftEn;

  inputShiftReg: process(reset, clock)
  begin
    if reset = '1' then
      dataInShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if dataInShift1 = '1' then
        dataInShiftReg(dataInShiftReg'high downto 1) <= dataInShiftReg(dataInShiftReg'high-1 downto 0);
        dataInShiftReg(0) <= MISO;
      end if;
    end if;
  end process inputShiftReg;

  delayCounterEnd: process(reset, clock)
  begin
    if reset = '1' then
      dataInEndDelayed <= '0';
    elsif rising_edge(clock) then
      dataInEndDelayed <= sequenceCounterEnd;
    end if;
  end process delayCounterEnd;

  dataInStore <= '1' when (sequenceCounterEnd = '0') and (dataInEndDelayed = '1') else '0';
--  dataInStore <= '1' when sequenceCounterEnd = '1';

  storeDataIn: process(reset, clock)
  begin
    if reset = '1' then
      dataIn <= (others => '0');
    elsif rising_edge(clock) then
      if dataInStore = '1' then
        dataIn <= dataInShiftReg;
      end if;
    end if;
  end process storeDataIn;

end RTL;





-- VHDL Entity SPI.spiWrite.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:39:54 31.10.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY spiWrite IS
   GENERIC( 
      dataBitNb : positive := 8
   );
   PORT( 
      reset          : IN     std_ulogic;
      clock          : IN     std_ulogic;
      dataOut        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutEmpty   : IN     std_ulogic;
      dataOutEnabled : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutRd      : OUT    std_ulogic;
      busy           : IN     std_ulogic;
      sendFrame      : IN     std_ulogic;
      dataWr         : OUT    std_ulogic
   );

-- Declarations

END spiWrite ;





--
-- VHDL Architecture SPI.spiWrite.rtl
--
-- Created:
--          by - uadmin.UNKNOWN (WE3877)
--          at - 08:57:33 26.09.2012
--
-- using Mentor Graphics HDL Designer(TM) 2009.2 (Build 10)
--
ARCHITECTURE rtl OF spiWrite IS

  signal dataWr_int : std_ulogic;
  
  -- FSM
  type readStateType is (
    idle,
    write_data,
    wait_nBusy
  );
  signal readState     : readStateType;

BEGIN

---------------------------------------------------------
-- FSM NextState
--
  readFsm: process(reset, clock)
  begin
    if reset = '1' then
      readState <= idle;
    elsif rising_edge(clock) then
      case readState is
        when idle =>
          if dataOutEmpty = '0' and busy = '0' then
            readState <= write_data;
          end if;
        when write_data =>
          readState <= wait_nBusy;
        when wait_nBusy =>
          if busy = '0' then
            if dataOutEmpty = '1' then
              readState <= idle;
            else
              readState <= write_data;
            end if;
          end if;
        when others => 
          readState <= idle;
      end case;
    end if;
  end process readFsm;

---------------------------------------------------------
-- FSM output
--
  outputFsm: process(readState,dataOutEmpty,sendFrame)
  begin
    -- Default values
    dataOutRd <= '0';
    dataWr_int <= '0';
    case readState is
      when idle =>
      when write_data =>
        if (dataOutEmpty = '0') and (sendFrame = '1') then
          dataOutRd <= '1';
          dataWr_int <= '1';
        end if;
      when wait_nBusy =>
    end case;
  end process outputFsm;

---------------------------------------------------------
-- Concurrent Statement 
--
  dataOutEnabled <= dataOut when dataOutEmpty = '0'
               else (others => '1');
  dataWr <= dataWr_int;
  
END ARCHITECTURE rtl;





--
-- VHDL Architecture SPI.spiFifo.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 15:42:56 28.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

LIBRARY Memory;
LIBRARY SPI;

ARCHITECTURE struct OF spiFifo IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL dataValid         : std_ulogic;
   SIGNAL dataIn            : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL en2x              : std_ulogic;
   SIGNAL dataOut           : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL slaveSel          : std_ulogic;
   SIGNAL dataOutEnabled    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL dataOutEmpty      : std_ulogic;
   SIGNAL sendFrame         : std_ulogic;
   SIGNAL dataOutRd         : std_ulogic;
   SIGNAL busy              : std_ulogic;
   SIGNAL dataWr            : std_ulogic;
   SIGNAL endTransfer_delay : std_ulogic;
   SIGNAL endTransfer_int   : std_ulogic;


   -- Component Declarations
   COMPONENT FIFO
   GENERIC (
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT (
      write   : IN     std_ulogic ;
      clock   : IN     std_ulogic ;
      reset   : IN     std_ulogic ;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic ;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic ;
      full    : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiTimer
   GENERIC (
      clockPeriod : positive := 1;
      framePeriod : positive := 1
   );
   PORT (
      en2x      : OUT    std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      sendFrame : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiTransceiver
   GENERIC (
      dataBitNb : positive   := 8;
      cPol      : std_ulogic := '0';
      cPha      : std_ulogic := '0'
   );
   PORT (
      sClk      : OUT    std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      dataOut   : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataWr    : IN     std_ulogic ;
      dataIn    : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      en2x      : IN     std_ulogic ;
      MOSI      : OUT    std_ulogic ;
      MISO      : IN     std_ulogic ;
      slaveSel  : OUT    std_ulogic ;
      dataValid : OUT    std_ulogic ;
      busy      : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiWrite
   GENERIC (
      dataBitNb : positive := 8
   );
   PORT (
      reset          : IN     std_ulogic ;
      clock          : IN     std_ulogic ;
      dataOut        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutEmpty   : IN     std_ulogic ;
      dataOutEnabled : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutRd      : OUT    std_ulogic ;
      busy           : IN     std_ulogic ;
      sendFrame      : IN     std_ulogic ;
      dataWr         : OUT    std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : FIFO USE ENTITY Memory.FIFO;
   FOR ALL : spiTimer USE ENTITY SPI.spiTimer;
   FOR ALL : spiTransceiver USE ENTITY SPI.spiTransceiver;
   FOR ALL : spiWrite USE ENTITY SPI.spiWrite;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 endTranser_gen
   endTransfer_int <= dataValid and not slaveSel;
   -- Add delay for FIFO to write data
   delay: process(reset, clock)
   begin
     if reset = '1' then
       endTransfer_delay <= '0';
       endTransfer <= '0';    
     elsif rising_edge(clock) then
       endTransfer_delay <= endTransfer_int;
       endTransfer <= endTransfer_delay;
     end if;
   end process delay; 

   -- HDL Embedded Text Block 2 inv_SS
   SS_n <= not slaveSel;


   -- Instance port mappings.
   Master_FIFO : FIFO
      GENERIC MAP (
         dataBitNb => dataBitNb,
         depth     => fifoDepth
      )
      PORT MAP (
         write   => masterWr,
         clock   => clock,
         reset   => reset,
         dataOut => dataOut,
         read    => dataOutRd,
         dataIn  => masterData,
         empty   => dataOutEmpty,
         full    => masterFull
      );
   Slave_FIFO : FIFO
      GENERIC MAP (
         dataBitNb => dataBitNb,
         depth     => fifoDepth
      )
      PORT MAP (
         write   => dataValid,
         clock   => clock,
         reset   => reset,
         dataOut => slaveData,
         read    => slaveRd,
         dataIn  => dataIn,
         empty   => slaveEmpty,
         full    => OPEN
      );
   spiTimer_inst : spiTimer
      GENERIC MAP (
         clockPeriod => spiClockPeriod,
         framePeriod => spiFramePeriod
      )
      PORT MAP (
         en2x      => en2x,
         clock     => clock,
         reset     => reset,
         sendFrame => sendFrame
      );
   spiTransceiver_inst : spiTransceiver
      GENERIC MAP (
         dataBitNb => dataBitNb,
         cPol      => cPol,
         cPha      => cPha
      )
      PORT MAP (
         sClk      => sClk,
         clock     => clock,
         reset     => reset,
         dataOut   => dataOutEnabled,
         dataWr    => dataWr,
         dataIn    => dataIn,
         en2x      => en2x,
         MOSI      => MOSI,
         MISO      => MISO,
         slaveSel  => slaveSel,
         dataValid => dataValid,
         busy      => busy
      );
   spiWrite_inst : spiWrite
      GENERIC MAP (
         dataBitNb => databitNb
      )
      PORT MAP (
         reset          => reset,
         clock          => clock,
         dataOut        => dataOut,
         dataOutEmpty   => dataOutEmpty,
         dataOutEnabled => dataOutEnabled,
         dataOutRd      => dataOutRd,
         busy           => busy,
         sendFrame      => sendFrame,
         dataWr         => dataWr
      );

END struct;




-- VHDL Entity OBC.SPI_SlaveSelect.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 15:01:38 28.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY SPI_SlaveSelect IS
   PORT( 
      SS_n        : IN     std_ulogic;
      SlaveSelect : IN     std_ulogic_vector (1 DOWNTO 0);
      SS1_n       : OUT    std_ulogic;
      SS2_n       : OUT    std_ulogic;
      SS3_n       : OUT    std_ulogic
   );

-- Declarations

END SPI_SlaveSelect ;





--
-- VHDL Architecture OBC.SPI_SlaveSelect.SlaveSelector
--
-- Created:
--          by - Lucas.Mayor
--          at - 15:52:31 15.07.2020
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE SlaveSelector OF SPI_SlaveSelect IS
BEGIN
    
    PROCESS (SS_n, SlaveSelect)
    BEGIN
        SS1_n <= '1';
        SS2_n <= '1';
        SS3_n <= '1';
        CASE SlaveSelect IS
            WHEN "01" => SS1_n <= SS_n;
            WHEN "10" => SS2_n <= SS_n;
            WHEN "11" => SS3_n <= SS_n;
            WHEN OTHERS =>
        END CASE; 
    END PROCESS;

END ARCHITECTURE SlaveSelector;





--
-- VHDL Architecture Board.obc_test_circuit.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:24:14 07.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY gates;
USE gates.gates.all;
USE ieee.numeric_std.all;

LIBRARY Board;
LIBRARY OBC;
LIBRARY RiscV;
LIBRARY SPI;

ARCHITECTURE struct OF obc_test_circuit IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL SPI1                 : std_logic_vector(PinNumber-1 DOWNTO 0);
   SIGNAL SPI2                 : std_logic_vector(PinNumber-1 DOWNTO 0);
   SIGNAL SPI3                 : std_logic_vector(PinNumber-1 DOWNTO 0);
   SIGNAL SPI4                 : std_logic_vector(PinNumber-1 DOWNTO 0);
   SIGNAL SPI4_DataIn          : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL SPI4_endTransfer     : std_logic;
   SIGNAL SPI4_masterFull      : std_ulogic;
   SIGNAL SPI4_slaveEmpty      : std_ulogic;
   SIGNAL SS_n                 : std_ulogic;
   SIGNAL io_gpioA_read        : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioA_write       : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioA_writeEnable : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioB_read        : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioB_write       : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioB_writeEnable : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioC_read        : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioC_write       : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioC_writeEnable : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioD_read        : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioD_write       : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_gpioD_writeEnable : std_logic_vector(31 DOWNTO 0);
   SIGNAL io_jtag_tck          : std_logic;
   SIGNAL io_jtag_tdi          : std_logic;
   SIGNAL io_jtag_tdo          : std_logic;
   SIGNAL io_jtag_tms          : std_logic;
   SIGNAL logic1               : std_uLogic;
   SIGNAL reset                : std_ulogic;
   SIGNAL resetSnch_N          : std_ulogic;
   SIGNAL resetSynch           : std_ulogic;


   -- Component Declarations
   COMPONENT DFF
   PORT (
      CLK : IN     std_uLogic ;
      CLR : IN     std_uLogic ;
      D   : IN     std_uLogic ;
      Q   : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT SPI_IO_Tristate
   GENERIC (
      dataBitNb : integer := 8;
      PinNumber : integer := 32
   );
   PORT (
      SPI_DataIn       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI_endTransfer  : IN     std_logic ;
      SPI_masterFull   : IN     std_ulogic ;
      SPI_slaveEmpty   : IN     std_ulogic ;
      writeEnable_Risc : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      DataIn           : OUT    std_logic_vector (dataBitNb-1 DOWNTO 0);
      endTransfer      : OUT    std_uLogic ;
      masterFull       : OUT    std_uLogic ;
      slaveEmpty       : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT inverterIn
   PORT (
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT bufferUlogic
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;
   COMPONENT SPI_SlaveSelect
   PORT (
      SS_n        : IN     std_ulogic ;
      SlaveSelect : IN     std_ulogic_vector (1 DOWNTO 0);
      SS1_n       : OUT    std_ulogic ;
      SS2_n       : OUT    std_ulogic ;
      SS3_n       : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT Test
   PORT (
      clock : IN     std_ulogic ;
      reset : IN     std_ulogic ;
      Led1  : OUT    std_logic ;
      Led2  : OUT    std_logic ;
      Led3  : OUT    std_logic ;
      Led4  : OUT    std_logic ;
      Led5  : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT gpioBankControl
   GENERIC (
      PinNumber : positive := 32
   );
   PORT (
      write   : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      writeEn : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      read    : OUT    std_logic_vector (PinNumber-1 DOWNTO 0);
      pins    : INOUT  std_logic_vector (PinNumber-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT Murax
   PORT (
      io_asyncReset        : IN     std_ulogic;
      io_gpioA_read        : IN     std_logic_vector (31 DOWNTO 0);
      io_jtag_tck          : IN     std_logic;
      io_jtag_tdi          : IN     std_logic;
      io_jtag_tms          : IN     std_logic;
      io_mainClk           : IN     std_ulogic;
      io_gpioA_write       : OUT    std_logic_vector (31 DOWNTO 0);
      io_gpioA_writeEnable : OUT    std_logic_vector (31 DOWNTO 0);
      io_jtag_tdo          : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT spiFifo
   GENERIC (
      dataBitNb      : positive   := 8;
      fifoDepth      : positive   := 8;      --Max nbr of sequential transfers
      spiClockPeriod : positive   := 1;      --SPI clock divider
      spiFramePeriod : positive   := 1;      --SPI Inter Frame Gap
      cPol           : std_ulogic := '0';
      cPha           : std_ulogic := '0'
   );
   PORT (
      slaveRd     : IN     std_ulogic ;
      slaveData   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      clock       : IN     std_ulogic ;
      MISO        : IN     std_ulogic ;
      reset       : IN     std_ulogic ;
      MOSI        : OUT    std_ulogic ;
      slaveEmpty  : OUT    std_ulogic ;
      masterFull  : OUT    std_ulogic ;
      masterData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      masterWr    : IN     std_ulogic ;
      sClk        : OUT    std_ulogic ;
      endTransfer : OUT    std_logic ;
      SS_n        : OUT    std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : DFF USE ENTITY Board.DFF;
   FOR ALL : SPI_IO_Tristate USE ENTITY Board.SPI_IO_Tristate;
   FOR ALL : SPI_SlaveSelect USE ENTITY OBC.SPI_SlaveSelect;
   FOR ALL : Test USE ENTITY OBC.Test;
   FOR ALL : bufferUlogic USE ENTITY Gates.bufferUlogic;
   FOR ALL : gpioBankControl USE ENTITY OBC.gpioBankControl;
   FOR ALL : inverterIn USE ENTITY Board.inverterIn;
   FOR ALL : spiFifo USE ENTITY SPI.spiFifo;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 5 eb5
   logic1 <= '1';


   -- Instance port mappings.
   I_dff : DFF
      PORT MAP (
         CLK => clock,
         CLR => reset,
         D   => logic1,
         Q   => resetSnch_N
      );
   I14 : SPI_IO_Tristate
      GENERIC MAP (
         dataBitNb => 8,
         PinNumber => 32
      )
      PORT MAP (
         SPI_DataIn       => SPI4_DataIn,
         SPI_endTransfer  => SPI4_endTransfer,
         SPI_masterFull   => SPI4_masterFull,
         SPI_slaveEmpty   => SPI4_slaveEmpty,
         writeEnable_Risc => io_gpioD_writeEnable,
         DataIn           => SPI4(15 DOWNTO 8),
         endTransfer      => SPI4(20),
         masterFull       => SPI4(17),
         slaveEmpty       => SPI4(19)
      );
   I_inv1 : inverterIn
      PORT MAP (
         in1  => reset_N,
         out1 => reset
      );
   I_inv2 : inverterIn
      PORT MAP (
         in1  => resetSnch_N,
         out1 => resetSynch
      );
   I6 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => SPI1_MISO,
         out1 => SPI1_unused
      );
   I7 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => SPI2_MISO,
         out1 => SPI2_unused
      );
   I8 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => SPI3_MISO,
         out1 => SPI3_unused
      );
   I9 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => SPI4_MISO,
         out1 => SPI4_unused
      );
   U_0 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => fpgaIO0,
         out1 => io_jtag_tms
      );
   U_1 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => fpgaIO1,
         out1 => io_jtag_tdi
      );
   U_5 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => fpgaIO2,
         out1 => io_jtag_tck
      );
   U_6 : bufferUlogic
      GENERIC MAP (
         delay => gateDelay
      )
      PORT MAP (
         in1  => io_jtag_tdo,
         out1 => fpgaIO3
      );
   U_3 : SPI_SlaveSelect
      PORT MAP (
         SS_n        => SS_n,
         SlaveSelect => SPI4(22 DOWNTO 21),
         SS1_n       => SPI4_SS1_n,
         SS2_n       => SPI4_SS2_n,
         SS3_n       => OPEN
      );
   I1 : Test
      PORT MAP (
         clock => clock,
         reset => resetSynch,
         Led1  => Led1,
         Led2  => Led2,
         Led3  => Led3,
         Led4  => Led4,
         Led5  => Led5
      );
   I2 : gpioBankControl
      GENERIC MAP (
         PinNumber => 32
      )
      PORT MAP (
         write   => io_gpioA_write,
         writeEn => io_gpioA_writeEnable,
         read    => io_gpioA_read,
         pins    => SPI1
      );
   I3 : gpioBankControl
      GENERIC MAP (
         PinNumber => 32
      )
      PORT MAP (
         write   => io_gpioB_write,
         writeEn => io_gpioB_writeEnable,
         read    => io_gpioB_read,
         pins    => SPI2
      );
   I4 : gpioBankControl
      GENERIC MAP (
         PinNumber => 32
      )
      PORT MAP (
         write   => io_gpioC_write,
         writeEn => io_gpioC_writeEnable,
         read    => io_gpioC_read,
         pins    => SPI3
      );
   I5 : gpioBankControl
      GENERIC MAP (
         PinNumber => 32
      )
      PORT MAP (
         write   => io_gpioD_write,
         writeEn => io_gpioD_writeEnable,
         read    => io_gpioD_read,
         pins    => SPI4
      );
   U_4 : Murax
      PORT MAP (
         io_asyncReset        => reset,
         io_mainClk           => clock,
         io_jtag_tms          => io_jtag_tms,
         io_jtag_tdi          => io_jtag_tdi,
         io_jtag_tdo          => io_jtag_tdo,
         io_jtag_tck          => io_jtag_tck,
         io_gpioA_read        => io_gpioD_read,
         io_gpioA_write       => io_gpioD_write,
         io_gpioA_writeEnable => io_gpioD_writeEnable
      );
   U_2 : spiFifo
      GENERIC MAP (
         dataBitNb      => 8,
         fifoDepth      => 64,          --Max nbr of sequential transfers
         spiClockPeriod => 640,         --SPI clock divider
         spiFramePeriod => 64,          --SPI Inter Frame Gap
         cPol           => '0',
         cPha           => '0'
      )
      PORT MAP (
         slaveRd     => SPI4(18),
         slaveData   => SPI4_DataIn,
         clock       => clock,
         MISO        => SPI4_MISO,
         reset       => resetSynch,
         MOSI        => SPI4_MOSI,
         slaveEmpty  => SPI4_slaveEmpty,
         masterFull  => SPI4_masterFull,
         masterData  => SPI4(7 DOWNTO 0),
         masterWr    => SPI4(16),
         sClk        => SPI4_sClk,
         endTransfer => SPI4_endTransfer,
         SS_n        => SS_n
      );

END struct;




