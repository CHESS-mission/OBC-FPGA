-- VHDL Entity OBC.gpioBankControl.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 09:50:45 01.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY gpioBankControl IS
   GENERIC( 
      PinNumber : positive := 32
   );
   PORT( 
      write   : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      writeEn : IN     std_logic_vector (PinNumber-1 DOWNTO 0);
      read    : OUT    std_logic_vector (PinNumber-1 DOWNTO 0);
      pins    : INOUT  std_logic_vector (PinNumber-1 DOWNTO 0)
   );

-- Declarations

END gpioBankControl ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity Gates.bufferUlogicVector.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:19:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY bufferUlogicVector IS
   GENERIC( 
      dataBitNb : positive := 8;
      delay     : time     := gateDelay
   );
   PORT( 
      in1  : IN     std_uLogic_vector (dataBitNb-1 DOWNTO 0);
      out1 : OUT    std_uLogic_vector (dataBitNb-1 DOWNTO 0)
   );

-- Declarations

END bufferUlogicVector ;





ARCHITECTURE sim OF bufferUlogicVector IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




-- VHDL Entity IO.tristateBufferULogic.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 16:28:40 20.08.2009
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY tristateBufferULogic IS
   GENERIC( 
      delay : time := gateDelay
   );
   PORT( 
      OE   : IN     std_ulogic;
      in1  : IN     std_uLogic;
      out1 : OUT    std_uLogic
   );

-- Declarations

END tristateBufferULogic ;





ARCHITECTURE sim OF tristateBufferULogic IS
BEGIN
  out1 <= in1 after delay when OE = '1' else 'Z' after delay;
END ARCHITECTURE sim;





--
-- VHDL Architecture OBC.gpioBankControl.struct_tristate
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 09:55:32 01.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY IO;

ARCHITECTURE struct_tristate OF gpioBankControl IS

   -- Architecture declarations

   -- Internal signal declarations


   -- Component Declarations
   COMPONENT bufferUlogicVector
   GENERIC (
      dataBitNb : positive := 8;
      delay     : time     := gateDelay
   );
   PORT (
      in1  : IN     std_uLogic_vector (dataBitNb-1 DOWNTO 0);
      out1 : OUT    std_uLogic_vector (dataBitNb-1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT tristateBufferULogic
   GENERIC (
      delay : time := gateDelay
   );
   PORT (
      OE   : IN     std_ulogic ;
      in1  : IN     std_uLogic ;
      out1 : OUT    std_uLogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : bufferUlogicVector USE ENTITY Gates.bufferUlogicVector;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   U_1 : bufferUlogicVector
      GENERIC MAP (
         dataBitNb => PinNumber,
         delay     => gateDelay
      )
      PORT MAP (
         in1  => pins,
         out1 => read
      );

   g0: FOR i IN 0 TO PinNumber-1 GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : tristateBufferULogic USE ENTITY IO.tristateBufferULogic;
   -- pragma synthesis_on

   BEGIN
      U_0 : tristateBufferULogic
         GENERIC MAP (
            delay => gateDelay
         )
         PORT MAP (
            OE   => writeEn(i),
            in1  => write(i),
            out1 => pins(i)
         );
   END;
   END GENERATE g0;

END struct_tristate;




-- VHDL Entity OBC.gpioPinControl.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:42:54 28.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY gpioPinControl IS
   PORT( 
      write   : IN     std_ulogic;
      writeEn : IN     std_ulogic;
      read    : OUT    std_ulogic;
      pin     : INOUT  std_ulogic
   );

-- Declarations

END gpioPinControl ;





--
-- VHDL Architecture OBC.gpioPinControl.pinControl
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:35:18 28.07.2020
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE pinControl OF gpioPinControl IS

BEGIN

    PROCESS (writeEn, pin, write)
    BEGIN
        
        if writeEN = '1' then
            pin <= write;
            read <= write;
        else
            read <= pin;
        end if;
    END PROCESS;

END ARCHITECTURE pinControl;





-- VHDL Entity OBC.SPI_Control.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 14:38:01 02.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY SPI_Control IS
   GENERIC( 
      dataBitNb : integer := 8
   );
   PORT( 
      SPI1_DataOut     : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI1_MISO        : IN     std_ulogic;
      SPI1_Read        : IN     std_ulogic;
      SPI1_Select      : IN     std_ulogic_vector (1 DOWNTO 0);
      SPI1_Write       : IN     std_ulogic;
      SPI2_DataOut     : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI2_MISO        : IN     std_ulogic;
      SPI2_Read        : IN     std_ulogic;
      SPI2_Write       : IN     std_ulogic;
      SPI3_DataOut     : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI3_MISO        : IN     std_ulogic;
      SPI3_Read        : IN     std_ulogic;
      SPI3_Select      : IN     std_ulogic_vector (1 DOWNTO 0);
      SPI3_Write       : IN     std_ulogic;
      SPI4_DataOut     : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI4_MISO        : IN     std_ulogic;
      SPI4_Read        : IN     std_ulogic;
      SPI4_Select      : IN     std_ulogic_vector (1 DOWNTO 0);
      SPI4_Write       : IN     std_ulogic;
      clock            : IN     std_logic;
      reset            : IN     std_logic;
      SPI1_DataIn      : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI1_MOSI        : OUT    std_ulogic;
      SPI1_SS1_n       : OUT    std_ulogic;
      SPI1_SS2_n       : OUT    std_ulogic;
      SPI1_SS3_n       : OUT    std_ulogic;
      SPI1_endTransfer : OUT    std_logic;
      SPI1_masterFull  : OUT    std_ulogic;
      SPI1_sClk        : OUT    std_ulogic;
      SPI1_slaveEmpty  : OUT    std_ulogic;
      SPI2_DataIn      : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI2_MOSI        : OUT    std_ulogic;
      SPI2_SS1_n       : OUT    std_ulogic;
      SPI2_endTransfer : OUT    std_logic;
      SPI2_masterFull  : OUT    std_ulogic;
      SPI2_sClk        : OUT    std_ulogic;
      SPI2_slaveEmpty  : OUT    std_ulogic;
      SPI3_DataIn      : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI3_MOSI        : OUT    std_ulogic;
      SPI3_SS1_n       : OUT    std_ulogic;
      SPI3_SS2_n       : OUT    std_ulogic;
      SPI3_endTransfer : OUT    std_logic;
      SPI3_masterFull  : OUT    std_ulogic;
      SPI3_sClk        : OUT    std_ulogic;
      SPI3_slaveEmpty  : OUT    std_ulogic;
      SPI4_DataIn      : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      SPI4_MOSI        : OUT    std_ulogic;
      SPI4_SS1_n       : OUT    std_ulogic;
      SPI4_SS2_n       : OUT    std_ulogic;
      SPI4_endTransfer : OUT    std_logic;
      SPI4_masterFull  : OUT    std_ulogic;
      SPI4_sClk        : OUT    std_ulogic;
      SPI4_slaveEmpty  : OUT    std_ulogic
   );

-- Declarations

END SPI_Control ;





-- VHDL Entity OBC.SPI_SlaveSelect.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 15:01:38 28.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY SPI_SlaveSelect IS
   PORT( 
      SS_n        : IN     std_ulogic;
      SlaveSelect : IN     std_ulogic_vector (1 DOWNTO 0);
      SS1_n       : OUT    std_ulogic;
      SS2_n       : OUT    std_ulogic;
      SS3_n       : OUT    std_ulogic
   );

-- Declarations

END SPI_SlaveSelect ;





--
-- VHDL Architecture OBC.SPI_SlaveSelect.SlaveSelector
--
-- Created:
--          by - Lucas.Mayor
--          at - 15:52:31 15.07.2020
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE SlaveSelector OF SPI_SlaveSelect IS
BEGIN
    
    PROCESS (SS_n, SlaveSelect)
    BEGIN
        SS1_n <= '1';
        SS2_n <= '1';
        SS3_n <= '1';
        CASE SlaveSelect IS
            WHEN "01" => SS1_n <= SS_n;
            WHEN "10" => SS2_n <= SS_n;
            WHEN "11" => SS3_n <= SS_n;
            WHEN OTHERS =>
        END CASE; 
    END PROCESS;

END ARCHITECTURE SlaveSelector;





-- VHDL Entity SPI.spiFifo.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 07:39:39 11.11.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY spiFifo IS
   GENERIC( 
      dataBitNb      : positive   := 8;
      fifoDepth      : positive   := 8;      --Max nbr of sequential transfers
      spiClockPeriod : positive   := 1;      --SPI clock divider
      spiFramePeriod : positive   := 1;      --SPI Inter Frame Gap
      cPol           : std_ulogic := '0';
      cPha           : std_ulogic := '0'
   );
   PORT( 
      slaveRd     : IN     std_ulogic;
      slaveData   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      clock       : IN     std_ulogic;
      MISO        : IN     std_ulogic;
      reset       : IN     std_ulogic;
      MOSI        : OUT    std_ulogic;
      slaveEmpty  : OUT    std_ulogic;
      masterFull  : OUT    std_ulogic;
      masterData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      masterWr    : IN     std_ulogic;
      sClk        : OUT    std_ulogic;
      endTransfer : OUT    std_logic;
      SS_n        : OUT    std_ulogic
   );

-- Declarations

END spiFifo ;





-- VHDL Entity Memory.FIFO.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO IS
   GENERIC( 
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT( 
      write   : IN     std_ulogic;
      clock   : IN     std_ulogic;
      reset   : IN     std_ulogic;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic;
      full    : OUT    std_ulogic
   );

-- Declarations

END FIFO ;





-- VHDL Entity Memory.FIFO_oneRegister.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_oneRegister IS
   GENERIC( 
      dataBitNb : positive := 8
   );
   PORT( 
      write   : IN     std_ulogic;
      clock   : IN     std_ulogic;
      reset   : IN     std_ulogic;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic;
      full    : OUT    std_ulogic
   );

-- Declarations

END FIFO_oneRegister ;





architecture oneRegister of FIFO_oneRegister is

  signal dataRegister: std_ulogic_vector(dataIn'range);

begin

  writeReg: process(reset, clock)
  begin
    if reset = '1' then
      dataRegister <= (others => '0');
    elsif rising_edge(clock) then
      if write = '1' then
        dataRegister <= dataIn;
      end if;
    end if;
  end process writeReg;

  dataOut <= dataRegister;

  manageFlags: process(reset, clock)
  begin
    if reset = '1' then
      empty <= '1';
      full  <= '0';
    elsif rising_edge(clock) then
      if write = '1' then
        empty <= '0';
        full  <= '1';
      elsif read = '1' then
        empty <= '1';
        full  <= '0';
      end if;
    end if;
  end process manageFlags;

end oneRegister;





-- VHDL Entity Memory.FIFO_bram.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_bram IS
   GENERIC( 
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT( 
      write   : IN     std_ulogic;
      clock   : IN     std_ulogic;
      reset   : IN     std_ulogic;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic;
      full    : OUT    std_ulogic
   );

-- Declarations

END FIFO_bram ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




library Common;
  use Common.CommonLib.all;

architecture RTL of FIFO_bram is

  subtype register_type is std_ulogic_vector(dataIn'high downto 0);
  type memory_type is array (0 to depth-1) of register_type;

  signal writeCounter: unsigned(requiredBitNb(depth-1)-1 downto 0);
  signal readCounter: unsigned(writeCounter'range);
  signal memoryArray: memory_type;

  type fifoStateType is (
    sEmpty, sFull,
    sRead, sWrite, sWriteFirst,
    sReadWrite, sWait
  );
  signal fifoState: fifoStateType;
  signal emptyCondition, fullCondition, empty_int: std_ulogic;

begin
  ------------------------------------------------------------------------------
                                                      -- read and write counters
  updateWriteCounter: process(reset, clock)
  begin
    if reset = '1' then
      writeCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (write = '1') and  (fullCondition = '0') then
        writeCounter <= writeCounter + 1;
      end if;
    end if;
  end process updateWriteCounter;

  updateReadCounter: process(reset, clock)
  begin
    if reset = '1' then
      readCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '1') and  (empty_int = '0') then
        readCounter <= readCounter + 1;
      end if;
    end if;
  end process updateReadCounter;

  ------------------------------------------------------------------------------
                                                                -- memory access
  writeMem: process(clock)
  begin
    if rising_edge(clock) then
      if (write = '1') and (fullCondition = '0') then
        memoryArray(to_integer(writeCounter)) <= dataIn;
      end if;
    end if;
  end process writeMem;

  readMem: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '0') or (empty_int = '1') then
        dataOut <= memoryArray(to_integer(readCounter));
      else
        dataOut <= memoryArray(to_integer(readCounter+1));
      end if;
    end if;
  end process readMem;

  ------------------------------------------------------------------------------
                                                                     -- controls
  emptyCondition <= '1' when
      ( (fifoState = sRead) and (writeCounter = readCounter) ) or
        (fifoState = sEmpty)
    else '0';

  fullCondition <= '1' when
      ( (fifoState = sWrite) and (writeCounter = readCounter) ) or
        (fifoState = sFull)
    else '0';


  fifoControl: process(reset, clock)
  begin
    if reset = '1' then
      fifoState <= sEmpty;
    elsif rising_edge(clock) then
      case fifoState is
        when sEmpty =>
          if write = '1' then
            fifoState <= sWriteFirst;
          end if;
        when sFull =>
          if (read = '1') then
            fifoState <= sRead;
          end if;
        when sRead =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
		      elsif emptyCondition = '1' then
            fifoState <= sEmpty;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWriteFirst =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWrite =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
		      elsif fullCondition = '1' then
            fifoState <= sFull;
          elsif write = '1' then
            fifoState <= sWrite;
          else
            fifoState <= sWait;
          end if;
        when sReadWrite =>
          if (read = '0') and (write = '0') then
            fifoState <= sWait;
          elsif (read = '1') and (write = '0') then
            fifoState <= sRead;
          elsif (write = '1') and (read = '0') then
            fifoState <= sWrite;
          end if;
        when sWait =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
          elsif write = '1' then
            fifoState <= sWrite;
          end if;
        when others => null;
      end case;
    end if;
  end process fifoControl;
  

  full <= '1' when 
        (fifoState = sFull) or
        (fullCondition = '1')
    else '0';

  empty_int <= '1' when
        (fifoState = sEmpty) or
        (fifoState = sWriteFirst) or
        ( (emptyCondition = '1') and (fifoState = sRead) )
    else '0';
  empty <= empty_int;
  
end RTL;




--
-- VHDL Architecture Memory.FIFO.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:16 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Memory;

ARCHITECTURE struct OF FIFO IS

   -- Architecture declarations

   -- Internal signal declarations


   -- Component Declarations
   COMPONENT FIFO_bram
   GENERIC (
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT (
      write   : IN     std_ulogic ;
      clock   : IN     std_ulogic ;
      reset   : IN     std_ulogic ;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic ;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic ;
      full    : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT FIFO_oneRegister
   GENERIC (
      dataBitNb : positive := 8
   );
   PORT (
      write   : IN     std_ulogic ;
      clock   : IN     std_ulogic ;
      reset   : IN     std_ulogic ;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic ;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic ;
      full    : OUT    std_ulogic 
   );
   END COMPONENT;


BEGIN

   -- Instance port mappings.

   g0: IF depth <= 1 GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : FIFO_oneRegister USE ENTITY Memory.FIFO_oneRegister;
   -- pragma synthesis_on

   BEGIN
      I1 : FIFO_oneRegister
         GENERIC MAP (
            dataBitNb => dataBitNb
         )
         PORT MAP (
            write   => write,
            clock   => clock,
            reset   => reset,
            dataOut => dataOut,
            read    => read,
            dataIn  => dataIn,
            empty   => empty,
            full    => full
         );
   END;
   END GENERATE g0;

   g1: IF depth > 1 GENERATE
   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
   -- pragma synthesis_on

   BEGIN
      I0 : FIFO_bram
         GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => depth
         )
         PORT MAP (
            write   => write,
            clock   => clock,
            reset   => reset,
            dataOut => dataOut,
            read    => read,
            dataIn  => dataIn,
            empty   => empty,
            full    => full
         );
   END;
   END GENERATE g1;

END struct;




-- VHDL Entity SPI.spiTimer.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:39:54 31.10.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY spiTimer IS
   GENERIC( 
      clockPeriod : positive := 1;
      framePeriod : positive := 1
   );
   PORT( 
      en2x      : OUT    std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      sendFrame : OUT    std_ulogic
   );

-- Declarations

END spiTimer ;





LIBRARY Common;
USE Common.CommonLib.all;

architecture RTL of spiTimer is

  signal clockPeriodCounter: unsigned(requiredBitNb(clockPeriod)-1 downto 0);
  signal clockPeriodEnd: std_uLogic;
  signal framePeriodCounter: unsigned(requiredBitNb(framePeriod)-1 downto 0);
  signal framePeriodEnd: std_uLogic;

begin

  divide1: process(reset, clock)
  begin
    if reset = '1' then
      clockPeriodCounter <= (others => '0');
    elsif rising_edge(clock) then
      if clockPeriodEnd = '1' then
        clockPeriodCounter <= (others => '0');
      else
        clockPeriodCounter <= clockPeriodCounter + 1;
      end if;
    end if;
  end process divide1;

  endOfCount1: process(clockPeriodCounter)
  begin
    if clockPeriodCounter >= clockPeriod-1 then
      clockPeriodEnd <= '1';
    else
      clockPeriodEnd <= '0';
    end if;
  end process endOfCount1;

  en2x <= clockPeriodEnd;

  divide2: process(reset, clock)
  begin
    if reset = '1' then
      framePeriodCounter <= (others => '0');
    elsif rising_edge(clock) then
      if framePeriodEnd = '1' then
        framePeriodCounter <= (others => '0');
      else
        framePeriodCounter <= framePeriodCounter + 1;
      end if;
    end if;
  end process divide2;

  endOfCount2: process(framePeriodCounter)
  begin
    if framePeriodCounter >= framePeriod-1 then
      framePeriodEnd <= '1';
    else
      framePeriodEnd <= '0';
    end if;
  end process endOfCount2;

  sendFrame <= framePeriodEnd;

end RTL;




-- VHDL Entity SPI.spiTransceiver.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:39:54 31.10.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY spiTransceiver IS
   GENERIC( 
      dataBitNb : positive   := 8;
      cPol      : std_ulogic := '0';
      cPha      : std_ulogic := '0'
   );
   PORT( 
      sClk      : OUT    std_ulogic;
      clock     : IN     std_ulogic;
      reset     : IN     std_ulogic;
      dataOut   : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataWr    : IN     std_ulogic;
      dataIn    : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      en2x      : IN     std_ulogic;
      MOSI      : OUT    std_ulogic;
      MISO      : IN     std_ulogic;
      slaveSel  : OUT    std_ulogic;
      dataValid : OUT    std_ulogic;
      busy      : OUT    std_ulogic
   );

-- Declarations

END spiTransceiver ;





--------------------------------------------------------------------------------
-- Copyright 2013 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- SPI master interface
--   More information: http://wiki.hevs.ch/uit/index.php5/Components/IP/SPI  
--
--   Created on 2012-10-01
--
--   Version: 1.0
--   Author: François Corthay (francois.corthay@hevs.ch)
--------------------------------------------------------------------------------

LIBRARY Common;
USE Common.CommonLib.all;

architecture RTL of spiTransceiver is

  signal sequenceCounter    : unsigned(requiredBitNb(2*dataBitNb+1)-1 downto 0);
  signal sequenceCounterEnd : std_uLogic;
  signal sending            : std_uLogic;
  signal dataValid1         : std_uLogic;
  signal dataAvail          : std_ulogic;
  signal serialClock        : std_uLogic;
  signal slaveSel_int       : std_ulogic;

  signal dataOutShift           : std_uLogic;
  signal dataOutShiftReg        : std_ulogic_vector(dataOut'range);
  signal dataOutBufferReg       : std_ulogic_vector(dataOut'range);
  signal masterOut0, masterOut1 : std_uLogic;

  signal dataInShift, dataInShift1     : std_uLogic;
  signal dataInEndDelayed, dataInStore : std_uLogic;
  signal dataInShiftReg                : std_ulogic_vector(dataIn'range);

begin
  ------------------------------------------------------------------------------
                                                                       -- timing
  countSequence: process(reset, clock)
  begin
    if reset = '1' then
      sequenceCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (slaveSel_int = '0' and dataAvail = '1') then -- first transfer
        sequenceCounter <= sequenceCounter + 1;
      elsif en2x = '1' then
        if sequenceCounterEnd = '1' then
          if dataAvail = '0' then                      -- Last Transfer
            sequenceCounter <= (others => '0');
          else                                         -- Continue with next Transfer
            sequenceCounter <= to_unsigned(1, sequenceCounter'length);
          end if;
        elsif sequenceCounter > 0 then
          sequenceCounter <= sequenceCounter + 1;
        end if;
      end if;
    end if;
  end process countSequence;

  endOfSequence: process(sequenceCounter)
  begin
    if sequenceCounter = 2*dataBitNb+1 then
      sequenceCounterEnd <= '1';
    else
      sequenceCounterEnd <= '0';
    end if;
  end process endOfSequence;

  sending <= '1' when sequenceCounter /= 0 else '0';
  serialClock <= not(sequenceCounter(0)) and sending;

  busy <= dataAvail;
  
  signalValid: process(reset, clock)
  begin
    if reset = '1' then
      dataValid1 <= '0';
      dataValid <= '0';
    elsif rising_edge(clock) then
      dataValid1 <= sequenceCounterEnd and en2x;
      dataValid <= dataValid1;
    end if;
  end process signalValid;

  ------------------------------------------------------------------------------
                                                                     -- data out
  dataOutShift <= en2x when (sequenceCounter(0) = '0') and (sending = '1') else '0';

  outputShiftReg: process(reset, clock)
  begin
    if reset = '1' then
      dataOutBufferReg <= (others => '0');
      dataAvail        <= '0';
      dataOutShiftReg  <= (others => '0');
    elsif rising_edge(clock) then
      -- data buffering
      if dataWr = '1' then
        dataAvail <= '1';
        dataOutBufferReg <= dataOut;
      end if;
      -- read buffered data
      if (slaveSel_int = '1' and dataAvail = '1' and dataValid1 = '1') or -- while sending
         (slaveSel_int = '0' and dataAvail = '1') then                    -- first transfer
        dataOutShiftReg <= dataOutBufferReg;
        dataAvail <= '0';
      elsif dataOutShift = '1' then
        dataOutShiftReg(dataOutShiftReg'high downto 1) <= dataOutShiftReg(dataOutShiftReg'high-1 downto 0);
      end if;
    end if;
  end process outputShiftReg;

  masterOut0 <= dataOutShiftReg(dataOutShiftReg'high);

  delayMasterOut: process(reset, clock)
  begin
    if reset = '1' then
      masterOut1 <= '0';
    elsif rising_edge(clock) then
      if en2x = '1' then
        masterOut1 <= masterOut0;
      end if;
    end if;
  end process delayMasterOut;

  deglitchOutputs: process(reset, clock)
  begin
    if reset = '1' then
      sClk         <= '0';
      MOSI         <= '0';
      slaveSel_int <= '0';
    elsif rising_edge(clock) then
      if cPol = '0' then
        sClk <= serialClock;
      else
        sClk <= not(serialClock);
      end if;
      if cPha = '0' then
        MOSI <= masterOut0;
      else
        MOSI <= masterOut1;
      end if;
      slaveSel_int <= sending;
    end if;
  end process deglitchOutputs;
  
  slaveSel <= slaveSel_int;

  ------------------------------------------------------------------------------
                                                                      -- data in
  dataInShift <= en2x
--      when (sequenceCounter(0) = '0') and (sending = '1')
      when ( (sequenceCounter(0) = '1') and (sending = '1') and (cPha = '0') )
        or ( (sequenceCounter(0) = '0') and (sending = '1') and (cPha = '1') )
    else '0';

  delayInShiftEn: process(reset, clock)
  begin
    if reset = '1' then
      dataInShift1 <= '0';
    elsif rising_edge(clock) then
      dataInShift1 <= dataInShift;
    end if;
  end process delayInShiftEn;

  inputShiftReg: process(reset, clock)
  begin
    if reset = '1' then
      dataInShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if dataInShift1 = '1' then
        dataInShiftReg(dataInShiftReg'high downto 1) <= dataInShiftReg(dataInShiftReg'high-1 downto 0);
        dataInShiftReg(0) <= MISO;
      end if;
    end if;
  end process inputShiftReg;

  delayCounterEnd: process(reset, clock)
  begin
    if reset = '1' then
      dataInEndDelayed <= '0';
    elsif rising_edge(clock) then
      dataInEndDelayed <= sequenceCounterEnd;
    end if;
  end process delayCounterEnd;

  dataInStore <= '1' when (sequenceCounterEnd = '0') and (dataInEndDelayed = '1') else '0';
--  dataInStore <= '1' when sequenceCounterEnd = '1';

  storeDataIn: process(reset, clock)
  begin
    if reset = '1' then
      dataIn <= (others => '0');
    elsif rising_edge(clock) then
      if dataInStore = '1' then
        dataIn <= dataInShiftReg;
      end if;
    end if;
  end process storeDataIn;

end RTL;





-- VHDL Entity SPI.spiWrite.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 13:39:54 31.10.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY spiWrite IS
   GENERIC( 
      dataBitNb : positive := 8
   );
   PORT( 
      reset          : IN     std_ulogic;
      clock          : IN     std_ulogic;
      dataOut        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutEmpty   : IN     std_ulogic;
      dataOutEnabled : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutRd      : OUT    std_ulogic;
      busy           : IN     std_ulogic;
      sendFrame      : IN     std_ulogic;
      dataWr         : OUT    std_ulogic
   );

-- Declarations

END spiWrite ;





--
-- VHDL Architecture SPI.spiWrite.rtl
--
-- Created:
--          by - uadmin.UNKNOWN (WE3877)
--          at - 08:57:33 26.09.2012
--
-- using Mentor Graphics HDL Designer(TM) 2009.2 (Build 10)
--
ARCHITECTURE rtl OF spiWrite IS

  signal dataWr_int : std_ulogic;
  
  -- FSM
  type readStateType is (
    idle,
    write_data,
    wait_nBusy
  );
  signal readState     : readStateType;

BEGIN

---------------------------------------------------------
-- FSM NextState
--
  readFsm: process(reset, clock)
  begin
    if reset = '1' then
      readState <= idle;
    elsif rising_edge(clock) then
      case readState is
        when idle =>
          if dataOutEmpty = '0' and busy = '0' then
            readState <= write_data;
          end if;
        when write_data =>
          readState <= wait_nBusy;
        when wait_nBusy =>
          if busy = '0' then
            if dataOutEmpty = '1' then
              readState <= idle;
            else
              readState <= write_data;
            end if;
          end if;
        when others => 
          readState <= idle;
      end case;
    end if;
  end process readFsm;

---------------------------------------------------------
-- FSM output
--
  outputFsm: process(readState,dataOutEmpty,sendFrame)
  begin
    -- Default values
    dataOutRd <= '0';
    dataWr_int <= '0';
    case readState is
      when idle =>
      when write_data =>
        if (dataOutEmpty = '0') and (sendFrame = '1') then
          dataOutRd <= '1';
          dataWr_int <= '1';
        end if;
      when wait_nBusy =>
    end case;
  end process outputFsm;

---------------------------------------------------------
-- Concurrent Statement 
--
  dataOutEnabled <= dataOut when dataOutEmpty = '0'
               else (others => '1');
  dataWr <= dataWr_int;
  
END ARCHITECTURE rtl;





--
-- VHDL Architecture SPI.spiFifo.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 15:42:56 28.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

LIBRARY Memory;
LIBRARY SPI;

ARCHITECTURE struct OF spiFifo IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL dataValid         : std_ulogic;
   SIGNAL dataIn            : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL en2x              : std_ulogic;
   SIGNAL dataOut           : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL slaveSel          : std_ulogic;
   SIGNAL dataOutEnabled    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
   SIGNAL dataOutEmpty      : std_ulogic;
   SIGNAL sendFrame         : std_ulogic;
   SIGNAL dataOutRd         : std_ulogic;
   SIGNAL busy              : std_ulogic;
   SIGNAL dataWr            : std_ulogic;
   SIGNAL endTransfer_delay : std_ulogic;
   SIGNAL endTransfer_int   : std_ulogic;


   -- Component Declarations
   COMPONENT FIFO
   GENERIC (
      dataBitNb : positive := 8;
      depth     : positive := 8
   );
   PORT (
      write   : IN     std_ulogic ;
      clock   : IN     std_ulogic ;
      reset   : IN     std_ulogic ;
      dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      read    : IN     std_ulogic ;
      dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      empty   : OUT    std_ulogic ;
      full    : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiTimer
   GENERIC (
      clockPeriod : positive := 1;
      framePeriod : positive := 1
   );
   PORT (
      en2x      : OUT    std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      sendFrame : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiTransceiver
   GENERIC (
      dataBitNb : positive   := 8;
      cPol      : std_ulogic := '0';
      cPha      : std_ulogic := '0'
   );
   PORT (
      sClk      : OUT    std_ulogic ;
      clock     : IN     std_ulogic ;
      reset     : IN     std_ulogic ;
      dataOut   : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataWr    : IN     std_ulogic ;
      dataIn    : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      en2x      : IN     std_ulogic ;
      MOSI      : OUT    std_ulogic ;
      MISO      : IN     std_ulogic ;
      slaveSel  : OUT    std_ulogic ;
      dataValid : OUT    std_ulogic ;
      busy      : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiWrite
   GENERIC (
      dataBitNb : positive := 8
   );
   PORT (
      reset          : IN     std_ulogic ;
      clock          : IN     std_ulogic ;
      dataOut        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutEmpty   : IN     std_ulogic ;
      dataOutEnabled : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      dataOutRd      : OUT    std_ulogic ;
      busy           : IN     std_ulogic ;
      sendFrame      : IN     std_ulogic ;
      dataWr         : OUT    std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : FIFO USE ENTITY Memory.FIFO;
   FOR ALL : spiTimer USE ENTITY SPI.spiTimer;
   FOR ALL : spiTransceiver USE ENTITY SPI.spiTransceiver;
   FOR ALL : spiWrite USE ENTITY SPI.spiWrite;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 endTranser_gen
   endTransfer_int <= dataValid and not slaveSel;
   -- Add delay for FIFO to write data
   delay: process(reset, clock)
   begin
     if reset = '1' then
       endTransfer_delay <= '0';
       endTransfer <= '0';    
     elsif rising_edge(clock) then
       endTransfer_delay <= endTransfer_int;
       endTransfer <= endTransfer_delay;
     end if;
   end process delay; 

   -- HDL Embedded Text Block 2 inv_SS
   SS_n <= not slaveSel;


   -- Instance port mappings.
   Master_FIFO : FIFO
      GENERIC MAP (
         dataBitNb => dataBitNb,
         depth     => fifoDepth
      )
      PORT MAP (
         write   => masterWr,
         clock   => clock,
         reset   => reset,
         dataOut => dataOut,
         read    => dataOutRd,
         dataIn  => masterData,
         empty   => dataOutEmpty,
         full    => masterFull
      );
   Slave_FIFO : FIFO
      GENERIC MAP (
         dataBitNb => dataBitNb,
         depth     => fifoDepth
      )
      PORT MAP (
         write   => dataValid,
         clock   => clock,
         reset   => reset,
         dataOut => slaveData,
         read    => slaveRd,
         dataIn  => dataIn,
         empty   => slaveEmpty,
         full    => OPEN
      );
   spiTimer_inst : spiTimer
      GENERIC MAP (
         clockPeriod => spiClockPeriod,
         framePeriod => spiFramePeriod
      )
      PORT MAP (
         en2x      => en2x,
         clock     => clock,
         reset     => reset,
         sendFrame => sendFrame
      );
   spiTransceiver_inst : spiTransceiver
      GENERIC MAP (
         dataBitNb => dataBitNb,
         cPol      => cPol,
         cPha      => cPha
      )
      PORT MAP (
         sClk      => sClk,
         clock     => clock,
         reset     => reset,
         dataOut   => dataOutEnabled,
         dataWr    => dataWr,
         dataIn    => dataIn,
         en2x      => en2x,
         MOSI      => MOSI,
         MISO      => MISO,
         slaveSel  => slaveSel,
         dataValid => dataValid,
         busy      => busy
      );
   spiWrite_inst : spiWrite
      GENERIC MAP (
         dataBitNb => databitNb
      )
      PORT MAP (
         reset          => reset,
         clock          => clock,
         dataOut        => dataOut,
         dataOutEmpty   => dataOutEmpty,
         dataOutEnabled => dataOutEnabled,
         dataOutRd      => dataOutRd,
         busy           => busy,
         sendFrame      => sendFrame,
         dataWr         => dataWr
      );

END struct;




--
-- VHDL Architecture OBC.SPI_Control.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 14:38:01 02.08.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
USE ieee.numeric_std.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY OBC;
LIBRARY SPI;

ARCHITECTURE struct OF SPI_Control IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL SPI1_SS_n : std_ulogic;
   SIGNAL SPI3_SS_n : std_ulogic;
   SIGNAL SPI4_SS_n : std_ulogic;


   -- Component Declarations
   COMPONENT SPI_SlaveSelect
   PORT (
      SS_n        : IN     std_ulogic ;
      SlaveSelect : IN     std_ulogic_vector (1 DOWNTO 0);
      SS1_n       : OUT    std_ulogic ;
      SS2_n       : OUT    std_ulogic ;
      SS3_n       : OUT    std_ulogic 
   );
   END COMPONENT;
   COMPONENT spiFifo
   GENERIC (
      dataBitNb      : positive   := 8;
      fifoDepth      : positive   := 8;      --Max nbr of sequential transfers
      spiClockPeriod : positive   := 1;      --SPI clock divider
      spiFramePeriod : positive   := 1;      --SPI Inter Frame Gap
      cPol           : std_ulogic := '0';
      cPha           : std_ulogic := '0'
   );
   PORT (
      slaveRd     : IN     std_ulogic ;
      slaveData   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      clock       : IN     std_ulogic ;
      MISO        : IN     std_ulogic ;
      reset       : IN     std_ulogic ;
      MOSI        : OUT    std_ulogic ;
      slaveEmpty  : OUT    std_ulogic ;
      masterFull  : OUT    std_ulogic ;
      masterData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
      masterWr    : IN     std_ulogic ;
      sClk        : OUT    std_ulogic ;
      endTransfer : OUT    std_logic ;
      SS_n        : OUT    std_ulogic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : SPI_SlaveSelect USE ENTITY OBC.SPI_SlaveSelect;
   FOR ALL : spiFifo USE ENTITY SPI.spiFifo;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   U_0 : SPI_SlaveSelect
      PORT MAP (
         SS_n        => SPI1_SS_n,
         SlaveSelect => SPI1_Select,
         SS1_n       => SPI1_SS1_n,
         SS2_n       => SPI1_SS2_n,
         SS3_n       => SPI1_SS3_n
      );
   U_1 : SPI_SlaveSelect
      PORT MAP (
         SS_n        => SPI3_SS_n,
         SlaveSelect => SPI3_Select,
         SS1_n       => SPI3_SS1_n,
         SS2_n       => SPI3_SS2_n,
         SS3_n       => OPEN
      );
   U_2 : SPI_SlaveSelect
      PORT MAP (
         SS_n        => SPI4_SS_n,
         SlaveSelect => SPI4_Select,
         SS1_n       => SPI4_SS1_n,
         SS2_n       => SPI4_SS2_n,
         SS3_n       => OPEN
      );
   U_3 : spiFifo
      GENERIC MAP (
         dataBitNb      => 8,
         fifoDepth      => 8,         --Max nbr of sequential transfers
         spiClockPeriod => 1,         --SPI clock divider
         spiFramePeriod => 1,         --SPI Inter Frame Gap
         cPol           => '0',
         cPha           => '0'
      )
      PORT MAP (
         slaveRd     => SPI1_Read,
         slaveData   => SPI1_DataIn,
         clock       => clock,
         MISO        => SPI1_MISO,
         reset       => reset,
         MOSI        => SPI1_MOSI,
         slaveEmpty  => SPI1_slaveEmpty,
         masterFull  => SPI1_masterFull,
         masterData  => SPI1_DataOut,
         masterWr    => SPI1_Write,
         sClk        => SPI1_sClk,
         endTransfer => SPI1_endTransfer,
         SS_n        => SPI1_SS_n
      );
   U_4 : spiFifo
      GENERIC MAP (
         dataBitNb      => 8,
         fifoDepth      => 8,         --Max nbr of sequential transfers
         spiClockPeriod => 1,         --SPI clock divider
         spiFramePeriod => 1,         --SPI Inter Frame Gap
         cPol           => '0',
         cPha           => '0'
      )
      PORT MAP (
         slaveRd     => SPI2_Read,
         slaveData   => SPI2_DataIn,
         clock       => clock,
         MISO        => SPI2_MISO,
         reset       => reset,
         MOSI        => SPI2_MOSI,
         slaveEmpty  => SPI2_slaveEmpty,
         masterFull  => SPI2_masterFull,
         masterData  => SPI2_DataOut,
         masterWr    => SPI2_Write,
         sClk        => SPI2_sClk,
         endTransfer => SPI2_endTransfer,
         SS_n        => SPI2_SS1_n
      );
   U_5 : spiFifo
      GENERIC MAP (
         dataBitNb      => 8,
         fifoDepth      => 8,         --Max nbr of sequential transfers
         spiClockPeriod => 1,         --SPI clock divider
         spiFramePeriod => 1,         --SPI Inter Frame Gap
         cPol           => '0',
         cPha           => '0'
      )
      PORT MAP (
         slaveRd     => SPI3_Read,
         slaveData   => SPI3_DataIn,
         clock       => clock,
         MISO        => SPI3_MISO,
         reset       => reset,
         MOSI        => SPI3_MOSI,
         slaveEmpty  => SPI3_slaveEmpty,
         masterFull  => SPI3_masterFull,
         masterData  => SPI3_DataOut,
         masterWr    => SPI3_Write,
         sClk        => SPI3_sClk,
         endTransfer => SPI3_endTransfer,
         SS_n        => SPI3_SS_n
      );
   U_6 : spiFifo
      GENERIC MAP (
         dataBitNb      => 8,
         fifoDepth      => 8,         --Max nbr of sequential transfers
         spiClockPeriod => 1,         --SPI clock divider
         spiFramePeriod => 1,         --SPI Inter Frame Gap
         cPol           => '0',
         cPha           => '0'
      )
      PORT MAP (
         slaveRd     => SPI4_Read,
         slaveData   => SPI4_DataIn,
         clock       => clock,
         MISO        => SPI4_MISO,
         reset       => reset,
         MOSI        => SPI4_MOSI,
         slaveEmpty  => SPI4_slaveEmpty,
         masterFull  => SPI4_masterFull,
         masterData  => SPI4_DataOut,
         masterWr    => SPI4_Write,
         sClk        => SPI4_sClk,
         endTransfer => SPI4_endTransfer,
         SS_n        => SPI4_SS_n
      );

END struct;




-- VHDL Entity OBC.Test.symbol
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 10:30:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY Test IS
   PORT( 
      clock : IN     std_ulogic;
      reset : IN     std_ulogic;
      Led1  : OUT    std_logic;
      Led2  : OUT    std_logic;
      Led3  : OUT    std_logic;
      Led4  : OUT    std_logic;
      Led5  : OUT    std_logic
   );

-- Declarations

END Test ;





--
-- VHDL Architecture OBC.Test.struct
--
-- Created:
--          by - student.UNKNOWN (DESKTOP-3I0F3HP)
--          at - 10:30:44 14.07.2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;


ARCHITECTURE struct OF Test IS

   -- Architecture declarations

   -- Internal signal declarations



BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 5 eb5
     process(clock, reset)
     begin
       if reset = '1' then
         Led1 <= '0';
       elsif rising_edge(clock) then
         Led1 <= not Led1;
       end if;
     end process;

   -- HDL Embedded Text Block 6 eb6
     process(clock, reset)
     begin
       if reset = '1' then
         Led2 <= '0';
   	  Led3 <= '0';
   	  Led4 <= '0';
   	  Led5 <= '0';
       elsif rising_edge(clock) then
         Led2 <= '0';
   	  Led3 <= '0';
   	  Led4 <= '0';
   	  Led5 <= '0';
       end if;
     end process;


   -- Instance port mappings.

END struct;




